# Задание 4.## Беловицкий Владислав БПИ198---Примечание: не стал ставить отбивки в markdown, чтобы не портить запросы, см. исходный файл.## Задача 1.Reader (ID, LastName, FirstName, Address, BirthDate)</br>Book (ISBN, Title, Author, PagesNum, PubYear, PubName)</br>Publisher (PubName, PubAdress)</br>Category (CategoryName, ParentCat)</br>Copy (ISBN, CopyNumber, ShelfPosition)</br>Borrowing (ReaderNr, ISBN, CopyNumber, ReturnDate)</br>BookCat (ISBN, CategoryName )### а) Какие фамилии читателей в Москве?SELECT LastNameFROM ReaderWHERE Address = 'Москва'### б) Какие книги (author, title) брал Иван Иванов?SELECT DISTINCT 	b.Author	,b.TitleFROM Borrowing brJOIN Book b ON b.ISBN = br.ISBNJOIN Reader r ON r.ID = br.ReaderNrWHERE r.FirstName = 'Иван' AND r.LastName = 'Иванов'</br>(DISTINCT для того, чтобы исключить из выборки повторяющиеся записи, т.к. читатель мог брать одну книгу много раз) ### в) Какие книги (ISBN) из категории "Горы" не относятся к категории "Путешествия"? Подкатегории не обязательно принимать во внимание!#### Вариант 1 (без учета подкатегорий)SELECT b.ISBNFROM Book bJOIN BookCat bc ON bc.ISBN = b.ISBNWHERE bc.CategoryName = 'Горы' AND bc.CategoryName != 'Путешествия'#### Вариант 2 (с учетом подкатегорий)Не тестировал, но должно быть примерно так (WITH REQURSIVE взят из PostrgreSql). Рекурсивно достаем подкатегории категории 'Путешествия' и вычитаем это множество из категорий книги. <br>WITH REQURSIVE CategoryWithСhildren  (CategoryName, ParentCat)AS (  --корневая категория  SELECT	CategoryName, ParentCat  FROM Category  WHERE CategoryName = 'Путешествия'    UNION --ALL  SELECT	CategoryName, ParentCat  FROM Category c  JOIN CategoryWithСhildren cwc ON cwc.CategoryName = c.ParentCat)SELECT b.ISBNFROM Book bJOIN BookCat bc ON bc.ISBN = b.ISBNLEFT JOIN CategoryWithСhildren cwc ON cwc.CategoryName = bc.CategoryNameWHERE bc.CategoryName = 'Горы' AND cwc.CategoryName IS NULL### г) Какие читатели (LastName, FirstName) брали книги, которые были возвращены?SELECT r.LastName	,r.FirstNameFROM Reader rJOIN Borrowing br ON br.ReaderNr = r.IDWHERE br.ReturnDate <= GETDATE()--или так:--br.ReturnDate IS NOT NULL####д) Какие читатели (LastName, FirstName) брали хотя бы одну книгу, которую брал также Иван Иванов (не включайте Ивана Иванова в результат)?SELECT r.LastName	,r.FirstNameFROM Reader rJOIN Borrowing br ON br.ReaderNr = r.IDJOIN     (        SELECT TOP(1) brt.ISBN, rt.ID        FROM Reader rt        JOIN Borrowing brt ON brt.ReaderNr = rt.ID        WHERE rt.FirstName = 'Иван' AND rt.LastName = 'Иванов'    ) AS tempReaderBookON br.ISBN = tempReaderBook.ISBN AND r.ID != tempReaderBook.ID## Задача 2.City (Name, Region)</br>Station (Name, #Tracks, CityName, Region)</br>Train (TrainNr, Length, StartStationName, EndStationName)</br>Connection (FromStation, ToStation, TrainNr, Departure, Arrival)</br>Предположим, что отношение "Connection" уже содержит транзитивное замыкание. Когда поезд 101 отправляется из Москвы в Санкт-Петербург через Тверь, содержит кортежи для связи Москва->Тверь, Тверь-Санкт-Петербург и Москва->Санкт-Петербург. Сформулируйте следующие запросы в реляционной алгебре:### а) Найдите все прямые рейсы из Москвы в Тверь.SELECT TrainNrFROM ConnectionWHERE FromStation = 'Москва' AND ToStation = 'Тверь'EXCEPTSELECT TrainNrFROM ConnectionWHERE FromStation != 'Москва' OR ToStation != 'Тверь'</br> Поскольку Connection содержит транзитивное замыкание, для поиска прямых рейсов необходимо исключить поезда, которые едут с пересадками.### б) Найдите все многосегментные маршруты, имеющие точно однодневный трансфер из Москвы в Санкт-Петербург (первое отправление и прибытие в конечную точку должны быть в одну и ту же дату). Вы можете применить функцию DAY () к атрибутам Departure и Arrival, чтобы определить дату.SELECT DISTINCT с1.TrainNrFROM Сonnection с1JOIN Connection c2 ON c2.TrainNr = c1.TrainNrWHERE c1.FromStation = 'Москва' AND c1.ToStation = 'Санкт-Петербург' AND Day(c1.Departure) = Day(c1.Arrival)AND (c2.FromStation != 'Москва' OR c2.ToStation != 'Санкт-Петербург') --в с1 ищем транзитивное замыкание, с2 необходима для того, чтобы учесть многосегментность### в) Что изменится в выражениях для а) и б), если отношение "Connection" не содержит дополнительных кортежей для транзитивного замыкания, поэтому многосегментный маршрут Москва-> Тверь-> Санкт-Петербург содержит только кортежи Москва-> Тверь и Тверь-Санкт-Петербург?#### Измененное а)SELECT TrainNrFROM ConnectionWHERE FromStation = 'Москва' AND ToStation = 'Тверь'-- теперь нет транзитивного замыкания, значит все кортежи можно считать прямыми рейсами#### Измененное б)SELECT DISTINCT с1.TrainNrFROM Сonnection с1JOIN Connection c2 ON c2.TrainNr = c1.TrainNr AND c2.FromStation = c1.ToStationWHERE c1.FromStation = 'Москва' AND c2.ToStation = 'Санкт-Петербург' AND Day(c1.Departure) = Day(c2.Arrival)AND c1.ToStation != 'Санкт-Петербург' OR c2.FromStation != 'Москва') -- в c1 будет отправная точка маршрута, а в c2 конечная точка ## Задача 3.