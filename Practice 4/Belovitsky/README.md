# Задание 4.## Беловицкий Владислав БПИ198---Примечание: не стал ставить отбивки в markdown, чтобы не портить запросы, см. исходный файл.## Задача 1.```Reader (ID, LastName, FirstName, Address, BirthDate)Book (ISBN, Title, Author, PagesNum, PubYear, PubName)Publisher (PubName, PubAdress)Category (CategoryName, ParentCat)Copy (ISBN, CopyNumber, ShelfPosition)Borrowing (ReaderNr, ISBN, CopyNumber, ReturnDate)BookCat (ISBN, CategoryName )```### а) Какие фамилии читателей в Москве?```SELECT LastNameFROM ReaderWHERE Address = 'Москва'```### б) Какие книги (author, title) брал Иван Иванов?```SELECT DISTINCT 	b.Author	,b.TitleFROM Borrowing brJOIN Book b ON b.ISBN = br.ISBNJOIN Reader r ON r.ID = br.ReaderNrWHERE r.FirstName = 'Иван' AND r.LastName = 'Иванов'```(DISTINCT для того, чтобы исключить из выборки повторяющиеся записи, т.к. читатель мог брать одну книгу много раз) ### в) Какие книги (ISBN) из категории "Горы" не относятся к категории "Путешествия"? Подкатегории не обязательно принимать во внимание!#### Вариант 1 (без учета подкатегорий)```SELECT b.ISBNFROM Book bJOIN BookCat bc ON bc.ISBN = b.ISBNWHERE bc.CategoryName = 'Горы' AND bc.CategoryName != 'Путешествия'```#### Вариант 2 (с учетом подкатегорий)Не тестировал, но должно быть примерно так (WITH REQURSIVE взят из PostrgreSql). Рекурсивно достаем подкатегории категории 'Путешествия' и вычитаем это множество из категорий книги. <br>```WITH REQURSIVE CategoryWithСhildren  (CategoryName, ParentCat)AS (  --корневая категория  SELECT	CategoryName, ParentCat  FROM Category  WHERE CategoryName = 'Путешествия'    UNION --ALL  SELECT	CategoryName, ParentCat  FROM Category c  JOIN CategoryWithСhildren cwc ON cwc.CategoryName = c.ParentCat)SELECT b.ISBNFROM Book bJOIN BookCat bc ON bc.ISBN = b.ISBNLEFT JOIN CategoryWithСhildren cwc ON cwc.CategoryName = bc.CategoryNameWHERE bc.CategoryName = 'Горы' AND cwc.CategoryName IS NULL```### г) Какие читатели (LastName, FirstName) брали книги, которые были возвращены?```SELECT r.LastName	,r.FirstNameFROM Reader rJOIN Borrowing br ON br.ReaderNr = r.IDWHERE br.ReturnDate <= GETDATE()--или так:--br.ReturnDate IS NOT NULL```####д) Какие читатели (LastName, FirstName) брали хотя бы одну книгу, которую брал также Иван Иванов (не включайте Ивана Иванова в результат)?```SELECT r.LastName	,r.FirstNameFROM Reader rJOIN Borrowing br ON br.ReaderNr = r.IDJOIN     (        SELECT TOP(1) brt.ISBN, rt.ID        FROM Reader rt        JOIN Borrowing brt ON brt.ReaderNr = rt.ID        WHERE rt.FirstName = 'Иван' AND rt.LastName = 'Иванов'    ) AS tempReaderBookON br.ISBN = tempReaderBook.ISBN AND r.ID != tempReaderBook.ID```## Задача 2.City (Name, Region)</br>Station (Name, #Tracks, CityName, Region)</br>Train (TrainNr, Length, StartStationName, EndStationName)</br>Connection (FromStation, ToStation, TrainNr, Departure, Arrival)</br>Предположим, что отношение "Connection" уже содержит транзитивное замыкание. Когда поезд 101 отправляется из Москвы в Санкт-Петербург через Тверь, содержит кортежи для связи Москва->Тверь, Тверь-Санкт-Петербург и Москва->Санкт-Петербург. Сформулируйте следующие запросы в реляционной алгебре:### а) Найдите все прямые рейсы из Москвы в Тверь.```SELECT DISTINCT c.TrainNrFROM Connection cJOIN Station sfrom ON sfrom.Name = c.FromStationJOIN Station sto ON sto.Name = c.ToStationWHERE sfrom.CityName = 'Москва' AND sto.CityName = 'Тверь'EXCEPTSELECT c.TrainNrFROM Connection cJOIN Station sfrom ON sfrom.Name = c.FromStationJOIN Station sto ON sto.Name = c.ToStationWHERE  sfrom.CityName != 'Москва' OR sto.CityName != 'Тверь'```Поскольку Connection содержит транзитивное замыкание, для поиска прямых рейсов необходимо исключить поезда, которые едут с пересадками.### б) Найдите все многосегментные маршруты, имеющие точно однодневный трансфер из Москвы в Санкт-Петербург (первое отправление и прибытие в конечную точку должны быть в одну и ту же дату). Вы можете применить функцию DAY () к атрибутам Departure и Arrival, чтобы определить дату.```SELECT DISTINCT с1.TrainNrFROM Сonnection с1JOIN Connection c2 ON c2.TrainNr = c1.TrainNrJOIN Station sfrom1 ON sfrom1.Name = c1.FromStationJOIN Station sto1 ON sto1.Name = c1.ToStationJOIN Station sfrom2 ON sfrom2.Name = c2.FromStationJOIN Station sto2 ON sto2.Name = c2.ToStationWHEREsfrom1.CityName = 'Москва' AND sto1.CityName = 'Санкт-Петербург' AND Day(c1.Departure) = Day(c1.Arrival)AND (sfrom2.CityName != 'Москва' OR sto2.CityName != 'Санкт-Петербург') ```В с1 ищем кортеж с транзитивным замыканием, с2 необходима для того, чтобы учесть многосегментность: ищем хотя бы один кортеж, в котором местом отправления будет не Москва или местом назначения будет не Санкт-Петербург.### в) Что изменится в выражениях для а) и б), если отношение "Connection" не содержит дополнительных кортежей для транзитивного замыкания, поэтому многосегментный маршрут Москва-> Тверь-> Санкт-Петербург содержит только кортежи Москва-> Тверь и Тверь-Санкт-Петербург?#### Измененное а)```SELECT c.TrainNrFROM Connection cJOIN Station sfrom ON sfrom.Name = c.FromStationJOIN Station sto ON sto.Name = c.ToStationWHERE sfrom.CityName = 'Москва' AND sto.CityName = 'Тверь'```Теперь нет транзитивного замыкания, значит все кортежи можно считать прямыми рейсами.#### Измененное б)```SELECT DISTINCT с1.TrainNrFROM Сonnection с1JOIN Connection c2 ON c2.TrainNr = c1.TrainNr AND c2.FromStation = c1.ToStationJOIN Station sfrom1 ON sfrom1.Name = c1.FromStationJOIN Station sto1 ON sto1.Name = c1.ToStationJOIN Station sfrom2 ON sfrom2.Name = c2.FromStationJOIN Station sto2 ON sto2.Name = c2.ToStationWHERE sfrom1.CityName = 'Москва' AND sto2.CityName = 'Санкт-Петербург' AND Day(c1.Departure) = Day(c2.Arrival)AND sto1.CityName != 'Санкт-Петербург' OR sfrom2.CityName != 'Москва') ```В c1 будет место отправления, в c2 место прибытия, причем, для учета многосегментности, местом прибытия c1 не должен являться Санкт-Петербург, а местом отправления c2 не должна являться Москва## Задача 3.